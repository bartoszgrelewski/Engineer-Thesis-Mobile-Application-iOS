import SwiftUI

@main
struct ScannerLidarAppMain: App {
    var body: some Scene {
        WindowGroup {
            NavigationStack {
                WelcomeView()
            }
        }
    }
}

import SwiftUI


struct WelcomeView: View {
    
    var body: some View {
        VStack {
            Image(systemName: "house.fill")
                .imageScale(.large)
                .scaleEffect(3)
                .foregroundColor(.accentColor)
                .padding(.bottom, 24)
                .symbolEffect(.pulse)
            
            Text("LiDAR Room Scanner")
                .font(.title)
                .fontWeight(.bold)
            Text("Let's start your journey!")
            
            Spacer()
                .frame(height: 50)
            
            NavigationLink("Launch Application") {
                ContentView()
            }
            .padding()
            .background(Color("AccentColor"))
            .foregroundColor(.white)
            .clipShape(Capsule())
            .fontWeight(.bold)
        }
        
    }
}

struct WelcomeView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationStack {
            WelcomeView()
        }
    }
}

import SwiftUI

struct ContentView: View {
    @State var selected = false
    
    var body: some View {
        NavigationView {
            VStack(spacing: 30) {
                NavigationLink(
                    destination: {
                        RoomCaptureScanView()
                    },
                    label: {
                        NavigationOptionView(
                            title: "Skanuj pomieszczenia 3d",
                            description: "Zacznij skan pomieszczenia rozpoczynajac od dowolonego wierzcholka sciany."
                        )
                    })
                NavigationLink(
                    destination: {
                        LidarDepthView()

                    },
                    label: {
                        NavigationOptionView(
                            title: "Odczyty LiDAR",
                            description: "Przejdz do widokow bezposrednio z modułu. Zobacz wizualizacje odczytow bezposrednio."
                        )
                    })
                NavigationLink(
                    destination: {
                        MyProjectsViewControllerRepresentable()
                        
                    },
                    label: {
                        NavigationOptionView(
                            title: "Moje projekty",
                            description: "Historia skanów 3D za pomocą aplikacji."
                        )
                    })
                Spacer()
            }
            .padding(.top, 20)
            .navigationTitle("Menu aplikacji")
        }
        .tint(Color(red: 255 / 255, green: 90 / 255, blue: 0))
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
            .previewLayout(.sizeThatFits)
            .preferredColorScheme(.dark)
    }
}

import SwiftUI

struct NavigationOptionView: View {
  @Environment(\.colorScheme)
  var colorScheme

  let title: String
  let description: String
  var body: some View {
    HStack {
      VStack(alignment: .leading, spacing: 4) {
        HStack {
          Text(title)
            .font(.headline)
            .foregroundColor(colorScheme == .dark ? Color.white : Color.black)
          Spacer()
        }
        Text(description)
          .font(.subheadline)
          .multilineTextAlignment(.leading)
          .foregroundColor(.gray)
      }
      Image(systemName: "chevron.right")
        .foregroundColor(colorScheme == .dark ? Color.white : Color.black)
        .padding([.leading, .trailing], 8)
    }
    .padding(.leading, 8)
  }
}

struct NavigationOptionView_Previews: PreviewProvider {
  static var previews: some View {
    Group {
      NavigationOptionView(
        title: "Title",
        description: "A descriptive text of what the view behind the navigation option is about."
      )
      .previewLayout(.sizeThatFits)
      .preferredColorScheme(.light)
      .previewDisplayName("Light Mode")

      NavigationOptionView(
        title: "Title",
        description: "A descriptive text of what the view behind the navigation option is about."
      )
      .previewLayout(.sizeThatFits)
      .preferredColorScheme(.dark)
      .previewDisplayName("Dark Mode")
    }
  }
}

import SwiftUI
import _SpriteKit_SwiftUI
import AVFoundation
import UIKit

struct RoomCaptureScanView: View {
    private let model = RoomCaptureModel.shared

    @State private var isScanning = false
    @State private var isShowingFloorPlan = false
    
    var body: some View {
        ZStack {
            RoomCaptureRepresentable()
                .ignoresSafeArea()
            
            VStack {
                Spacer()
                Button(isScanning ? "Zakończ" : "Zapisz plik") {
                    if isScanning {
                        stopSession()
                    } else {
                        exportFun()
                        isShowingFloorPlan = true
                    }
                }
                .padding()
                .background(Color("AccentColor"))
                .foregroundColor(.white)
                .clipShape(Capsule())
                .fontWeight(.bold)
                .padding(.bottom)
            }
        }
        .onAppear {
            startSession()
        }
    }
    
    
    private func startSession() {
        isScanning = true
        model.startSession()
        UIApplication.shared.isIdleTimerDisabled = true
    }
    
    private func stopSession() {
        isScanning = false
        model.stopSession()
        UIApplication.shared.isIdleTimerDisabled = false
    }
    
    private func exportFun() {
        guard model.finalRoom != nil else {return}
        var fm = FileManager.default
        var path = fm.urls(for: .documentDirectory, in: .userDomainMask).first!
        let fileName = "\("S" + UUID().uuidString).usdz"
        path.appendPathComponent(fileName)
        do{
            try model.finalRoom?.export(to: path.absoluteURL)
        }
        catch{
            print(error)
        }
    }
}

struct RoomCaptureScanView_Previews: PreviewProvider {
    static var previews: some View {
        RoomCaptureScanView()
    }
}

import Foundation
import RoomPlan

class RoomCaptureModel: RoomCaptureSessionDelegate {
    
    static let shared = RoomCaptureModel()
    let roomCaptureView: RoomCaptureView
    private let captureSessionConfig: RoomCaptureSession.Configuration
    private let roomBuilder: RoomBuilder
    var finalRoom: CapturedRoom?
    
    func encode(with coder: NSCoder) {
    }
    
    required init?(coder: NSCoder) {
        fatalError("Error when initializing RoomCaptureModel")
    }
    
    private init() {
        roomCaptureView = RoomCaptureView(frame: .zero)
        captureSessionConfig = RoomCaptureSession.Configuration()
        roomBuilder = RoomBuilder(options: [.beautifyObjects])
        
        roomCaptureView.captureSession.delegate = self
    }
    
    func startSession() {
        roomCaptureView.captureSession.run(configuration: captureSessionConfig)
    }
    
    func stopSession() {
        roomCaptureView.captureSession.stop()
    }
    
    func captureSession(
        _ session: RoomCaptureSession,
        didEndWith data: CapturedRoomData,
        error: Error?
    ) {
        if let error {
            print("Error ending capture session; \(error)")
        }
        
        Task {
            finalRoom = try! await roomBuilder.capturedRoom(from: data)
        }
    }
    
}

import RoomPlan
import SwiftUI


struct RoomCaptureRepresentable: UIViewRepresentable {
    
    func makeUIView(context: Context) -> RoomCaptureView {
        return RoomCaptureModel.shared.roomCaptureView
    }
    func updateUIView(_ uiView: RoomCaptureView, context: Context) {
    }
    
}

import RoomPlan
import SpriteKit

class FloorPlanScene: SKScene {
    
    private let surfaces: [CapturedRoom.Surface]
    private let objects: [CapturedRoom.Object]
    
    init(capturedRoom: CapturedRoom) {
        self.surfaces = capturedRoom.doors + capturedRoom.openings + capturedRoom.walls + capturedRoom.windows
        self.objects = capturedRoom.objects
        
        super.init(size: CGSize(width: 1500, height: 1500))
        
        self.scaleMode = .aspectFill
        self.anchorPoint = CGPoint(x: 0.5, y: 0.5)
        self.backgroundColor = floorPlanBackgroundColor
        
        addCamera()
        
        drawSurfaces()
        drawObjects()
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    override func didMove(to view: SKView) {
        let panGestureRecognizer = UIPanGestureRecognizer()
        panGestureRecognizer.addTarget(self, action: #selector(panGestureAction(_:)))
        view.addGestureRecognizer(panGestureRecognizer)
        
        let pinchGestureRecognizer = UIPinchGestureRecognizer()
        pinchGestureRecognizer.addTarget(self, action: #selector(pinchGestureAction(_:)))
        view.addGestureRecognizer(pinchGestureRecognizer)
    }
     
    private func drawSurfaces() {
        for surface in surfaces {
            let surfaceNode = FloorPlanSurface(capturedSurface: surface)
            addChild(surfaceNode)
        }
    }
    
    private func drawObjects() {
        for object in objects {
            let objectNode = FloorPlanObject(capturedObject: object)
            addChild(objectNode)
        }
    }
    
    private func addCamera() {
        let cameraNode = SKCameraNode()
        addChild(cameraNode)
        
        self.camera = cameraNode
    }
    
    // Variables that store camera scale and position at the start of a gesture
    private var previousCameraScale = CGFloat()
    private var previousCameraPosition = CGPoint()
    
    // Pan gestures only handle camera movement in this scene
    @objc private func panGestureAction(_ sender: UIPanGestureRecognizer) {
        guard let camera = self.camera else { return }
        
        if sender.state == .began {
            previousCameraPosition = camera.position
        }
        
        let translationScale = camera.xScale
        let panTranslation = sender.translation(in: self.view)
        let newCameraPosition = CGPoint(
            x: previousCameraPosition.x + panTranslation.x * -translationScale,
            y: previousCameraPosition.y + panTranslation.y * translationScale
        )
        
        camera.position = newCameraPosition
    }
    
    // Pinch gestures only handle camera movement in this scene
    @objc private func pinchGestureAction(_ sender: UIPinchGestureRecognizer) {
        guard let camera = self.camera else { return }
        
        if sender.state == .began {
            previousCameraScale = camera.xScale
        }
        
        camera.setScale(previousCameraScale * 1 / sender.scale)
    }
    
}

import SpriteKit
import RoomPlan

class FloorPlanSurface: SKNode {
    
    private let capturedSurface: CapturedRoom.Surface
    
    private var halfLength: CGFloat {
        return CGFloat(capturedSurface.dimensions.x) * scalingFactor / 2
    }
    
    private var pointA: CGPoint {
        return CGPoint(x: -halfLength, y: 0)
    }
    
    private var pointB: CGPoint {
        return CGPoint(x: halfLength, y: 0)
    }
    
    private var pointC: CGPoint {
        return pointB.rotateAround(point: pointA, by: 0.25 * .pi)
    }
    
    init(capturedSurface: CapturedRoom.Surface) {
        self.capturedSurface = capturedSurface
        
        super.init()
        
        // Set the surface's position using the transform matrix
        let surfacePositionX = -CGFloat(capturedSurface.transform.position.x) * scalingFactor
        let surfacePositionY = CGFloat(capturedSurface.transform.position.z) * scalingFactor
        self.position = CGPoint(x: surfacePositionX, y: surfacePositionY)
        
        // Set the surface's zRotation using the transform matrix
        self.zRotation = -CGFloat(capturedSurface.transform.eulerAngles.z - capturedSurface.transform.eulerAngles.y)
        
        // Draw the right surface
        switch capturedSurface.category {
        case .door:
            drawDoor()
        case .opening:
            drawOpening()
        case .wall:
            drawWall()
        case .window:
            drawWindow()
        @unknown default:
            drawWall()
        }
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    // MARK: - Draw

    private func drawDoor() {
        let hideWallPath = createPath(from: pointA, to: pointB)
        let doorPath = createPath(from: pointA, to: pointC)

        // Hide the wall underneath the door
        let hideWallShape = createShapeNode(from: hideWallPath)
        hideWallShape.strokeColor = floorPlanBackgroundColor
        hideWallShape.lineWidth = hideSurfaceWith
        hideWallShape.zPosition = hideSurfaceZPosition
        
        // The door itself
        let doorShape = createShapeNode(from: doorPath)
        doorShape.lineCap = .square
        doorShape.zPosition = doorZPosition
        
        // The door's arc
        let doorArcPath = CGMutablePath()
        doorArcPath.addArc(
            center: pointA,
            radius: halfLength * 2,
            startAngle: 0.25 * .pi,
            endAngle: 0,
            clockwise: true
        )
        
        // Create a dashed path
        let dashPattern: [CGFloat] = [24.0, 8.0]
        let dashedArcPath = doorArcPath.copy(dashingWithPhase: 1, lengths: dashPattern)

        let doorArcShape = createShapeNode(from: dashedArcPath)
        doorArcShape.lineWidth = doorArcWidth
        doorArcShape.zPosition = doorArcZPosition
        
        addChild(hideWallShape)
        addChild(doorShape)
        addChild(doorArcShape)
    }
    
    private func drawOpening() {
        let openingPath = createPath(from: pointA, to: pointB)
        
        // Hide the wall underneath the opening
        let hideWallShape = createShapeNode(from: openingPath)
        hideWallShape.strokeColor = floorPlanBackgroundColor
        hideWallShape.lineWidth = hideSurfaceWith
        hideWallShape.zPosition = hideSurfaceZPosition
        
        addChild(hideWallShape)
    }
    
    private func drawWall() {
        let wallPath = createPath(from: pointA, to: pointB)
        let wallShape = createShapeNode(from: wallPath)
        wallShape.lineCap = .square

        addChild(wallShape)
    }
    
    private func drawWindow() {
        let windowPath = createPath(from: pointA, to: pointB)
        
        // Hide the wall underneath the window
        let hideWallShape = createShapeNode(from: windowPath)
        hideWallShape.strokeColor = floorPlanBackgroundColor
        hideWallShape.lineWidth = hideSurfaceWith
        hideWallShape.zPosition = hideSurfaceZPosition
        
        // The window itself
        let windowShape = createShapeNode(from: windowPath)
        windowShape.lineWidth = windowWidth
        windowShape.zPosition = windowZPosition
        
        addChild(hideWallShape)
        addChild(windowShape)
    }
    
    // MARK: - Helper functions
    
    private func createPath(from pointA: CGPoint, to pointB: CGPoint) -> CGMutablePath {
        let path = CGMutablePath()
        path.move(to: pointA)
        path.addLine(to: pointB)
        
        return path
    }
    
    private func createShapeNode(from path: CGPath) -> SKShapeNode {
        let shapeNode = SKShapeNode(path: path)
        shapeNode.strokeColor = floorPlanSurfaceColor
        shapeNode.lineWidth = surfaceWith
        
        return shapeNode
    }
    
}
import SpriteKit
import RoomPlan

class FloorPlanObject: SKNode {
    
    private let capturedObject: CapturedRoom.Object
    
    // MARK: - Init
    
    init(capturedObject: CapturedRoom.Object) {
        self.capturedObject = capturedObject
        
        super.init()
        
        // Set the object's position using the transform matrix
        let objectPositionX = -CGFloat(capturedObject.transform.position.x) * scalingFactor
        let objectPositionY = CGFloat(capturedObject.transform.position.z) * scalingFactor
        self.position = CGPoint(x: objectPositionX, y: objectPositionY)
        
        // Set the object's zRotation using the transform matrix
        self.zRotation = -CGFloat(capturedObject.transform.eulerAngles.z - capturedObject.transform.eulerAngles.y)
        
        drawObject()
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    // MARK: - Draw
    
    private func drawObject() {
        // Calculate the object's dimensions
        let objectWidth = CGFloat(capturedObject.dimensions.x) * scalingFactor
        let objectHeight = CGFloat(capturedObject.dimensions.z) * scalingFactor
    
        // Create the object's rectangle
        let objectRect = CGRect(
            x: -objectWidth / 2,
            y: -objectHeight / 2,
            width: objectWidth,
            height: objectHeight
        )
        
        // A shape to fill the object
        let objectShape = SKShapeNode(rect: objectRect)
        objectShape.strokeColor = .clear
        objectShape.fillColor = floorPlanSurfaceColor
        objectShape.alpha = 0.3
        objectShape.zPosition = objectZPosition
        
        // And another shape for the outline
        let objectOutlineShape = SKShapeNode(rect: objectRect)
        objectOutlineShape.strokeColor = floorPlanSurfaceColor
        objectOutlineShape.lineWidth = objectOutlineWidth
        objectOutlineShape.lineJoin = .miter
        objectOutlineShape.zPosition = objectOutlineZPosition
                
        // Add both shapes to the node
        addChild(objectShape)
        addChild(objectOutlineShape)
    }
    
}

import UIKit

// Universal scaling factor
let scalingFactor: CGFloat = 200

// Colors
let floorPlanBackgroundColor = UIColor(named: "BackgroundColor")!
let floorPlanSurfaceColor = UIColor(named: "AccentColor")!

// Line widths
let surfaceWith: CGFloat = 22.0
let hideSurfaceWith: CGFloat = 24.0
let windowWidth: CGFloat = 8.0
let doorArcWidth: CGFloat = 8.0
let objectOutlineWidth: CGFloat = 8.0

// zPositions
let hideSurfaceZPosition: CGFloat = 1

let windowZPosition: CGFloat = 10

let doorZPosition: CGFloat = 20
let doorArcZPosition: CGFloat = 21

let objectZPosition: CGFloat = 30
let objectOutlineZPosition: CGFloat = 31

import CoreGraphics

extension CGPoint {
    
    func rotateAround(point: CGPoint, by angle: CGFloat) -> CGPoint {
        // Translate to origin
        let x1 = self.x - point.x
        let y1 = self.y - point.y
        
        // Apply rotation
        let x2 = x1 * cos(angle) - y1 * sin(angle)
        let y2 = x1 * sin(angle) + y1 * cos(angle)
        
        // Translate back
        let newX = x2 + point.x
        let newY = y2 + point.y
        
        return CGPoint(x: newX, y: newY)
    }
    
}

import SceneKit

extension simd_float4x4 {
    
    var eulerAngles: simd_float3 {
        simd_float3(
            x: asin(-self[2][1]),
            y: atan2(self[2][0], self[2][2]),
            z: atan2(self[0][1], self[1][1])
        )
    }

    var position: simd_float3 {
        simd_float3(
            x: self.columns.3.x,
            y: self.columns.3.y,
            z: self.columns.3.z
        )
    }
    
}

import SwiftUI
import UIKit
import RoomPlan

class MyProjectsView: UITableViewController {
    
    var scannedModels = [ScannedModel]()
    var dates = [String]()
    
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        getFilePaths()
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.scannedModels.removeAll()
        tableView.register(ModelCell.self, forCellReuseIdentifier: "CELL")
        
    }
    
    func getFilePaths(){
        let fm = FileManager.default
        let path = fm.urls(for: .documentDirectory, in: .userDomainMask).first!
        do{
            let content = try fm.contentsOfDirectory(atPath: path.path)
            for c in content{
                self.scannedModels.append(ScannedModel(filePath: path.appendingPathComponent(c).absoluteString, creationDate: "\(try! fm.attributesOfItem(atPath: path.appendingPathComponent(c).path)[.creationDate] as? NSDate)"))
            }
        }
        catch{
            print(error)
        }
    }
    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        super.tableView(tableView, numberOfRowsInSection: section)
        return scannedModels.count
    }
    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        super.tableView(tableView, cellForRowAt: indexPath)
        let cell = tableView.dequeueReusableCell(withIdentifier: "CELL") as! ModelCell
        cell.updateCell(path: scannedModels[indexPath.row].filePath, modelName: (scannedModels[indexPath.row].filePath as NSString).lastPathComponent,creationDate: self.getFileCreationDate(path: URL(string:  scannedModels[indexPath.row].filePath)!)!)
        return cell
    }
    override func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        super.tableView(tableView, heightForRowAt: indexPath)
        return view.frame.height/4
    }
    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let filePath = scannedModels[indexPath.row].filePath
        let selectedProjectView = SelectedProjectView(filePath: filePath)
        let hostingController = UIHostingController(rootView: selectedProjectView)
        self.navigationController?.pushViewController(hostingController, animated: true)
    }
}

extension MyProjectsView{
    func getFileCreationDate(path: URL) -> String?{
        do{
            if let date = try FileManager.default.attributesOfItem(atPath: path.path(percentEncoded: false))[.creationDate] as? Date{
                let formatter = DateFormatter()
                formatter.dateFormat = "MM/dd/yyyy"
                
                return formatter.string(from: date)
            }
        }
        catch{
            print(error)
        }
        return nil
    }
}

import SwiftUI
import SceneKit
import _SpriteKit_SwiftUI
import RoomPlan

struct SelectedProjectView: View {
    private let model = RoomCaptureModel.shared
    @State private var selectedButton: Int? = 3
    @State private var isShowingFloorPlan = false
    var filePath: String
    
    var body: some View {
        VStack {
            SceneKitView(path: filePath, configureUI: selectedButton ?? 3)
                .frame(maxWidth: CGFloat.infinity, maxHeight: CGFloat.infinity)
                .ignoresSafeArea()
            
            HStack {
                Group {
                    Button("WireFrame") {
                        selectedButton = 1
                    }
                    .buttonStyle(CustomButtonStyle(isSelected: selectedButton == 1))
                    
                    Divider().frame(height: 30)
                    
                    Button("Ambient") {
                        selectedButton = 2
                        
                    }
                    .buttonStyle(CustomButtonStyle(isSelected:  selectedButton == 2))
                    
                    Divider().frame(height: 30)
                    
                    Button("Default") {
                        selectedButton = 3
                    }
                    .buttonStyle(CustomButtonStyle(isSelected: selectedButton == 3))
                    
                    Divider().frame(height: 30)
                    
                    Button("2D Print") {
                        isShowingFloorPlan = true
                        selectedButton = 4
                    }
                    .buttonStyle(CustomButtonStyle(isSelected: selectedButton == 4))
                }
            }
            .frame(maxWidth: .infinity)
            .padding()
            .clipShape(Capsule())
            .background(Color.white)
            .shadow(radius: 3)
            .fontWeight(.bold)
            .padding(.bottom)
            .ignoresSafeArea()
        }
        .fullScreenCover(isPresented: $isShowingFloorPlan) {
            if let capturedRoom = model.finalRoom  {
                ZStack {
                    SpriteView(scene: FloorPlanScene(capturedRoom: capturedRoom))
                        .ignoresSafeArea()
                    
                    // Dismiss button
                    VStack {
                        HStack {
                            Spacer()
                            Button(action: {
                                isShowingFloorPlan = false
                            }) {
                                Image(systemName: "xmark.circle.fill")
                                    .font(.largeTitle)
                                    .padding()
                            }
                        }
                        Spacer()
                    }
                }
            } else {
                // Provide an alternative view or handling for when capturedRoom is nil
                Text("No floor plan data available")
            }
        }
    }
}


struct CustomButtonStyle: ButtonStyle {
    
    var isSelected: Bool
    
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .padding()
            .background(isSelected ? Color("AccentColor") : Color.clear)
            .foregroundColor(isSelected ? .white : .black)
            .clipShape(Capsule())
            .overlay(
                Capsule()
                    .stroke(Color.gray, lineWidth: 1)
            )
            .scaleEffect(configuration.isPressed ? 0.9 : 1.0)
    }
}

struct SceneKitView: UIViewRepresentable {
    var path: String
    var configureUI: Int
    var capturedRoom: CapturedRoom?
    var type: SCNLight.LightType! = .ambient
    
    
    func makeUIView(context: Context) -> SCNView {
        
        // root of SCN
        let model = try! SCNScene(url: URL(string: path)!)
        // View beyond hierarchy of SCN
        let modelViewer = SCNView()
        // SCN light settings
        let lightNode = SCNNode()
        
        lightNode.light = SCNLight()
        lightNode.light?.color = UIColor.lightGray
        lightNode.position = SCNVector3(x: 150, y: 10, z: 100)
        model.rootNode.addChildNode(lightNode)
        
        modelViewer.allowsCameraControl = true
        modelViewer.scene = model
        
        return modelViewer
    }
    
    func updateUIView(_ uiView: SCNView, context: Context) {
        guard let scene = uiView.scene else {
            return
        }
        uiView.debugOptions = []
        
        scene.rootNode.enumerateChildNodes { (node, _) in
            if node.light != nil || node.animationKeys.contains("colorChangeAnimation") {
                node.removeAllAnimations()
                node.removeFromParentNode()
            }
        }
        
        switch configureUI {
        case 1:
            scene.rootNode.enumerateChildNodes { (node, _) in
                node.geometry?.firstMaterial?.fillMode = .lines
            }
            let directionalLightNode = SCNNode()
            directionalLightNode.light = SCNLight()
            directionalLightNode.light?.type = .ambient
            directionalLightNode.light?.color = UIColor.white
            directionalLightNode.position = SCNVector3(x: 150, y: 10, z: 100)
            scene.rootNode.addChildNode(directionalLightNode)
            scene.background.contents = UIColor.black
            break
        case 2:
            let directionalLightNode = SCNNode()
            directionalLightNode.light = SCNLight()
            directionalLightNode.light?.type = .directional
            directionalLightNode.light?.color = UIColor.white
            directionalLightNode.light?.castsShadow = true
            directionalLightNode.orientation = SCNQuaternion(x: -1, y: 0, z: 0, w: Float.pi / 3)
            directionalLightNode.position = SCNVector3(x: 0, y: 10, z: 10)
            scene.rootNode.addChildNode(directionalLightNode)
            scene.rootNode.enumerateChildNodes { (node, _) in
                node.geometry?.firstMaterial?.fillMode = .fill
            }
            scene.background.contents = UIColor.gray
            break
        case 3:
            
            for _ in 1...5 {
                let lightNode = SCNNode()
                lightNode.light = SCNLight()
                lightNode.light?.type = .omni
                lightNode.position = SCNVector3(0, 10, 0)
                scene.rootNode.addChildNode(lightNode)
                
                let colors = [UIColor.red, UIColor.green, UIColor.blue, UIColor.cyan, UIColor.yellow, UIColor.magenta, UIColor.orange, UIColor.purple]
                let colorAction = SCNAction.customAction(duration: 8) { (node, elapsedTime) -> Void in
                    let percentage = CGFloat(elapsedTime) / 8.0
                    let colorIndex = Int(percentage * CGFloat(colors.count)) % colors.count
                    (node.light?.color = colors[colorIndex])
                }
                
                let moveAction = SCNAction.repeatForever(SCNAction.sequence([
                    SCNAction.move(by: SCNVector3(10, 0, 10), duration: 2),
                    SCNAction.move(by: SCNVector3(-10, 0, 10), duration: 2),
                    SCNAction.move(by: SCNVector3(-10, 0, -10), duration: 2),
                    SCNAction.move(by: SCNVector3(10, 0, -10), duration: 2)
                ]))
                
                let groupAction = SCNAction.group([colorAction, moveAction])
                lightNode.runAction(groupAction)
            }
            scene.background.contents = UIColor.systemBackground
            break
        case 4:
            
            break
        default:
            print("nil")
        }
    }
}


struct SelectedProjectView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationStack {
        }
    }
    
}

import Foundation

struct ScannedModel{
    let filePath: String
    let creationDate: String
}

import Foundation
import UIKit
import SceneKit

class ModelCell: UITableViewCell {
    
    var modelPreviewView: SCNView!
    var creationDate: UILabel!
    var modelName: UILabel!
    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        modelPreviewView = SCNView()
        creationDate = UILabel()
        modelName = UILabel()
        
        contentView.addSubview(modelPreviewView)
        contentView.addSubview(creationDate)
        contentView.addSubview(modelName)
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
    }
    
    
    override func layoutSubviews() {
        super.layoutSubviews()
        
        let width = contentView.frame.width
        let height = contentView.frame.height
        
        modelPreviewView.frame = CGRect(x: 0, y: 0, width: height, height: height)
        creationDate.frame = CGRect(x: height, y: 0, width: width - height, height: height/2)
        modelName.frame = CGRect(x: height, y: height/2, width: width - height, height: height/2)
    }
    
    override func setSelected(_ selected: Bool, animated: Bool) {
        super.setSelected(selected, animated: animated)
        
    }
    func updateCell(path: String,modelName: String,creationDate: String){
        self.modelName = UILabel()
        self.modelName.text = modelName
        addSubview(self.modelName)
        
        guard let url = URL(string: path) else {
            print("Invalid URL for the model")
            return
        }
        
        do {
            let model = try SCNScene(url: url)
            model.background.contents = UIColor.gray
            modelPreviewView.allowsCameraControl = true
            
            let lightnode = SCNNode()
            lightnode.light = SCNLight()
            
            lightnode.light?.type = .directional
            lightnode.position = SCNVector3(x: 0, y: 10, z: 20)
            lightnode.light?.color = #colorLiteral(red: 0.4745098054, green: 0.8392156959, blue: 0.9764705896, alpha: 1)
            model.rootNode.addChildNode(lightnode)
            modelPreviewView.scene = model
            self.modelName.text = modelName
            self.creationDate.text = creationDate
            
        } catch {
            print("Failed to load model: \(error)")
        }
        
        
    }
}

import SwiftUI

struct MyProjectsViewControllerRepresentable: UIViewControllerRepresentable {
    func makeUIViewController(context: Context) -> MyProjectsView {
        return MyProjectsView()
    }

    func updateUIViewController(_ uiViewController: MyProjectsView, context: Context) {
    }
}
struct LidarDepthView: View {
    
    @StateObject private var manager = CameraManager()
    
    @State private var maxDepth = Float(5.0)
    @State private var minDepth = Float(0.0)
    @State private var scaleMovement = Float(1.0)
    
    let maxRangeDepth = Float(15)
    let minRangeDepth = Float(0)
    
    var body: some View {
        VStack {
            HStack {
                Button {
                    manager.processingCapturedResult ? manager.resumeStream() : manager.startPhotoCapture()
                } label: {
                    Image(systemName: manager.processingCapturedResult ? "play.circle" : "camera.circle")
                        .font(.largeTitle)
                }
                
                Text("Depth Filtering")
                Toggle("Depth Filtering", isOn: $manager.isFilteringDepth).labelsHidden()
                Spacer()
            }
            SliderDepthBoundaryView(val: $maxDepth, label: "Max Depth", minVal: minRangeDepth, maxVal: maxRangeDepth)
            SliderDepthBoundaryView(val: $minDepth, label: "Min Depth", minVal: minRangeDepth, maxVal: maxRangeDepth)
            ScrollView {
                LazyVGrid(columns: [GridItem(.flexible(maximum: 600)), GridItem(.flexible(maximum: 600))]) {
                    
                    if manager.dataAvailable {
                        ZoomOnTap {
                            MetalTextureColorThresholdDepthView(
                                rotationAngle: rotationAngle,
                                maxDepth: $maxDepth,
                                minDepth: $minDepth,
                                capturedData: manager.capturedData
                            )
                            .aspectRatio(calcAspect(orientation: viewOrientation, texture: manager.capturedData.depth), contentMode: .fit)
                        }
                        ZoomOnTap {
                            MetalTextureColorZapView(
                                rotationAngle: rotationAngle,
                                maxDepth: $maxDepth,
                                minDepth: $minDepth,
                                capturedData: manager.capturedData
                            )
                            .aspectRatio(calcAspect(orientation: viewOrientation, texture: manager.capturedData.depth), contentMode: .fit)
                        }
                        ZoomOnTap {
                            MetalPointCloudView(
                                rotationAngle: rotationAngle,
                                maxDepth: $maxDepth,
                                minDepth: $minDepth,
                                scaleMovement: $scaleMovement,
                                capturedData: manager.capturedData
                            )
                            .aspectRatio(calcAspect(orientation: viewOrientation, texture: manager.capturedData.depth), contentMode: .fit)
                        }
                        ZoomOnTap {
                            DepthOverlay(manager: manager,
                                         maxDepth: $maxDepth,
                                         minDepth: $minDepth
                            )
                                .aspectRatio(calcAspect(orientation: viewOrientation, texture: manager.capturedData.depth), contentMode: .fit)
                        }
                    }
                }
            }
        }
    }
}

struct SliderDepthBoundaryView: View {
    @Binding var val: Float
    var label: String
    var minVal: Float
    var maxVal: Float
    let stepsCount = Float(200.0)
    var body: some View {
        HStack {
            Text(String(format: " %@: %.2f", label, val))
            Slider(
                value: $val,
                in: minVal...maxVal,
                step: (maxVal - minVal) / stepsCount
            ) {
            } minimumValueLabel: {
                Text(String(minVal))
            } maximumValueLabel: {
                Text(String(maxVal))
            }
        }
    }
}
